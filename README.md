# UNEVEN ARCHIVE
Archivator to be precise... 

Приветик. Мне лень грузить еще один класс поэтому вот так выглядит дерево (пока что

internal class Tree
        
	{ 
	    //public string code {get; set; } // тут я не уверен, если просто получить уровень поряжок обращения то все заебись, но как
	    				      // скорее всего никак если не жрать дохрена памяти
            public char character { get; set; } // символ
            public Tree left { get; set; } // левое поддерево
            public Tree right { get; set; } // правое поддерево
            public Tree(char character,int count)
            {
                this.character = character;
                this.count = count;
            }           
        }
	
и моя любимая алгоритмическая ебля ждет внизу
	
ВРОДЕ как для кодировки подходит та самая хрень с деревом, когда для кодов добавялется нуль слева в левой ветке и единица справа для правой ветки
Тогда рекурсивный КореньЛевоПраво обход выгружает все коды в правильном порядке.

Вот только некоторые коды он дублирует, начиная с 3 уровня. 

Причем бином ньютона 100% показывает где будет дубликат и сколько. (да я много выкурил)

Короче говоря, можно использовать такой алгоритм: tree.left.code = '0'+tree.code и tree.right.code=tree.right.code+'1'
то пасьянс сходится кроме лишних обращений. (ну и корень дерева ясен пень всегда 01)

qwertys -> 	

			
			q 01 
		w 001		e 011
	r 0001	   !t0011!== !y0011!	s 0111  <-пидор 'y' должен сидеть здесь а 's' на параше снизу	
		    个сверху хуйня个
	надо это как то избежать (на следующем уровне еще хуже)
	
		 
	бином ньютона чтобы далеко не гуглить
			1
		1		1
	1		!2!		1
	           个смекаешь?个
Способы решения надуманной проблемы		
1) Написать какую-нибудь функцию/модификацию для конструктора дерева, который бы такую хуйню не допускал
	считать уровни гиблое дерево, переменных на каждую рекурсивную ветку не напасешься
	
2) Придумать другой алгоритм дерева (но это дерево взешенное поэтому оптимально быстро строится)
есть  еще одна ебанутая идея ( но она скорее всего бесполезна )


	строить сначала только налево 01 001 0001...
	а потом рекурсивно для каждой ветки дописывать 1 справа. 
	можешь нарисовать дерево тогда поймешь, тогда обращение как надо 
	НО в таком случае нужно погружать в дерево в другом порядке.
	для первой итерации нужно погрузить по частоте обращения символы:
		1 2 4 7 11 16  (наращивание +1 +2 +3 +4 отсчитать легко)
	потом для второй итерации
		3 5 6 8 9 10 (ну или все остальные)
	
	У такого метода есть некоторое преимущество - у любой ячейки будет только один "родитель", в таком случае можно сделать
	еще возможность вернуться обратно. Это отчасти решает проблему передвижения более разожранного символа повыше. (просто двигаться вверх пока не встретится ячейка, которая идет и налево, и направо, и от нее еще один раз вверх). (грубо говоря пиздец как просто если надо обьясню)
	Но гораздо сложнее погружать, или я просто пока не допер.
	
		
Кроме того я не уверен как правильно заменять ячейки дерева когда нужно будет продвинуть более частую букву повыше
НУ И ПИЗДЕЦ 
	
# For random Vanyia who will see it

Как ты уже понял, я приготовил для тебя небольшой подарок ввиде недоделанного интерфейса.
*И НЕ СМОТРИ НА МЕНЯ ТАК. СДЕЛАТЬ 3 КНОПОЧКИ СО СВИСТЕЛКАМИ-ПЕРДЕЛКАМИ ЭТО ДОСТАТОЧНО СЛОЖНО*

# Getting Started

Я даю тебе формат входа в коде (* Здесь, потому что могу не дописать. 3 часа ночи * )

```
void WeDoThingsRightHere (string FilePath)
{
	//Some Code
}
```
Ну и впринципе всё... Я сам думал что пострашней выйдет что-то. Подключюсь позже, после того как стырю интерфейс у винрара (*Я почти знаю как это делать*)

# BUGS

Триггер IsMouseOver работает не на всей площади кнопки. Он перекрывается специальными символами 
(крестик выхода, прямоугольник фулсайза... *звучит как древние артефакты*)
из-за этого выделение более светлым иногда пропадает.
Фикс ясен но ужасен. Повесить этот тригер и на символ. 
Нужно что-то другое.
*P.S Только что пришла в голову идея повесить на Grid, в котором все эти объекты и находятся.
И пусть дурацкий Window.Resourse горит синим пламенем !*
